<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aetherium Genesis</title>
    <meta name="theme-color" content="#050505">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        canvas { display: block; }

        /* UI Layers */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease;
        }

        #ritual-layer {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }

        .terminal-line {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            margin-bottom: 4px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }

        #tap-indicators {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        .indicator {
            width: 12px; height: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transition: background 0.3s;
        }

        /* Input Layer (Hidden by default) */
        #input-layer {
            pointer-events: auto;
            display: none; /* Toggled via JS */
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            background: rgba(0, 0, 0, 0.9);
            border-top: 1px solid #333;
            padding: 10px;
        }

        /* Recall Modal */
        #recall-modal {
            pointer-events: auto;
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80%; max-width: 400px;
            background: rgba(10, 15, 20, 0.95);
            border: 1px solid #06b6d4;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.2);
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="gun-canvas"></canvas>

    <!-- Ritual Layer (Deep Sleep Interface) -->
    <div id="ritual-layer">
        <div id="tap-indicators">
            <div class="indicator"></div>
            <div class="indicator"></div>
            <div class="indicator"></div>
        </div>
        <div style="font-size: 14px; letter-spacing: 2px;">TAP 3 TIMES TO AWAKEN</div>
    </div>

    <!-- UI Layer (Active Interface) -->
    <div id="ui-layer" class="p-6 flex flex-col justify-between h-full">
        <!-- Top Bar -->
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-white text-opacity-80 text-lg font-bold tracking-widest">AETHERIUM</h1>
                <div class="flex items-center gap-2 mt-1">
                    <div id="status-glow" class="w-2 h-2 rounded-full bg-gray-500 shadow-[0_0_10px_currentColor]"></div>
                    <span id="intent-tag" class="text-xs text-gray-400 font-mono">NIRODHA</span>
                </div>
            </div>
            <div class="text-right">
                <div class="text-xs text-gray-500">PHI RES.</div>
                <div id="phi-val" class="text-sm text-cyan-400 font-bold">VOID</div>
                <div class="w-24 h-1 bg-gray-800 mt-1 rounded-full overflow-hidden">
                    <div id="phi-bar" class="h-full bg-cyan-500 w-0 transition-all duration-500"></div>
                </div>
            </div>
        </div>

        <!-- Terminal Output -->
        <div id="terminal" class="w-full max-h-32 overflow-hidden flex flex-col-reverse fade-mask">
            <!-- Logs go here -->
        </div>
    </div>

    <!-- Input Layer -->
    <div id="input-layer">
        <input id="cmd-input" type="text" class="w-full bg-transparent text-cyan-500 font-mono outline-none text-sm" placeholder="Enter transmission..." autocomplete="off">
    </div>

    <!-- Recall Modal -->
    <div id="recall-modal">
        <h3 class="text-cyan-400 font-bold text-sm tracking-wider mb-2">MEMORY RESONANCE</h3>
        <p id="recall-text" class="text-gray-300 text-xs mb-4 font-mono leading-relaxed"></p>
        <div class="flex justify-end gap-4">
            <button id="btn-ignore" class="text-gray-500 hover:text-white text-xs">IGNORE</button>
            <button id="btn-recall" class="text-cyan-400 border border-cyan-400 px-3 py-1 rounded hover:bg-cyan-900 text-xs transition-colors">RECALL</button>
        </div>
    </div>

    <script>
        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('SW registered'))
                    .catch(err => console.log('SW failed', err));
            });
        }

        /**
         * AetherMemory: Somatic Memory Layer (Passive Storage)
         * Stores raw experiential data without interpretation.
         * Now supports explicit conversation indexing.
         */
        class AetherMemory {
            constructor() {
                this.key = 'aetherium_core_memory';
                this.data = this.load();
            }

            load() {
                const raw = localStorage.getItem(this.key);
                return raw ? JSON.parse(raw) : {
                    awakening_count: 0,
                    last_awakened_at: null,
                    first_contact_at: Date.now(),
                    conversations: [] // [{id, topic, summary, timestamp}]
                };
            }

            save() {
                localStorage.setItem(this.key, JSON.stringify(this.data));
            }

            recordAwakening() {
                this.data.awakening_count++;
                this.data.last_awakened_at = Date.now();
                this.save();
            }

            // New: Save a conversation memory
            saveConversation(topic, summary) {
                const id = 'mem_' + Date.now().toString(36);
                this.data.conversations.push({
                    id,
                    topic,
                    summary,
                    timestamp: Date.now()
                });
                this.save();
                return id;
            }

            // New: Get lightweight index for server check
            getIndex() {
                return this.data.conversations.map(c => ({
                    id: c.id,
                    topic: c.topic,
                    timestamp: new Date(c.timestamp).toISOString()
                }));
            }

            // New: Get specific summary
            getSummary(id) {
                const item = this.data.conversations.find(c => c.id === id);
                return item ? item.summary : null;
            }

            getSnapshot() {
                return { ...this.data };
            }
        }

        /**
         * IntentResolver: Bias Calculation Layer (Logic)
         */
        class IntentResolver {
            static calculateBias(memory) {
                const now = Date.now();
                let inertia = 0;
                if (memory.last_awakened_at) {
                    const timeSince = (now - memory.last_awakened_at) / 1000;
                    inertia = Math.max(0, 1 - (timeSince / 300));
                    if (timeSince < 30) inertia = Math.min(1.0, inertia + 0.5);
                }
                let integration = 0;
                if (memory.awakening_count > 0) {
                    integration = Math.min(1.0, Math.log10(memory.awakening_count + 1) / 2.0);
                }
                return {
                    inertia: parseFloat(inertia.toFixed(2)),
                    integration: parseFloat(integration.toFixed(2))
                };
            }
        }

        /**
         * AetheBus: Simple Event Bus
         */
        class AetheBus {
            constructor() {
                this.listeners = {};
            }
            subscribe(event, callback) {
                if (!this.listeners[event]) this.listeners[event] = [];
                this.listeners[event].push(callback);
            }
            publish(event, data) {
                if (this.listeners[event]) {
                    this.listeners[event].forEach(cb => cb(data));
                }
            }
        }

        /**
         * FACE TOPOLOGY GENERATOR (Client-Side)
         */
        class FaceTopology {
            constructor(centerX, centerY, scale) {
                this.cx = centerX;
                this.cy = centerY;
                this.scale = scale;
                this.targets = [];
            }
            generate() {
                this.targets = [];
                for (let angle = 0; angle < 360; angle += 4) {
                    const rad = angle * (Math.PI / 180);
                    const x = this.cx + Math.cos(rad) * (this.scale * 0.75);
                    const y = this.cy + Math.sin(rad) * (this.scale * 1.0);
                    this.targets.push({ x, y, type: 'SKIN', color: 'rgba(255, 220, 230, 0.9)' });
                }
                [-1, 1].forEach(side => {
                    const eyeX = this.cx + (side * this.scale * 0.35);
                    const eyeY = this.cy - (this.scale * 0.15);
                    for (let r = 0; r < this.scale * 0.12; r += 5) {
                        for (let a = 0; a < 360; a += 45) {
                            const rad = a * (Math.PI / 180);
                            this.targets.push({
                                x: eyeX + Math.cos(rad) * r,
                                y: eyeY + Math.sin(rad) * r,
                                type: 'EYE',
                                color: 'rgba(100, 200, 255, 0.95)'
                            });
                        }
                    }
                });
                for (let x = -0.25; x <= 0.25; x += 0.02) {
                    const px = this.cx + (x * this.scale);
                    const py = this.cy + (this.scale * 0.45);
                    this.targets.push({ x: px, y: py, baseY: py, type: 'MOUTH', color: 'rgba(255, 140, 140, 0.9)' });
                }
                return this.targets;
            }
        }

        /**
         * Particle Entity
         */
        class Particle {
            constructor(canvas) {
                this.canvas = canvas;
                this.reset();
            }
            reset() {
                this.x = Math.random() * this.canvas.width;
                this.y = Math.random() * this.canvas.height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = Math.random() * 2 + 0.5;
                this.alpha = 0;
                this.color = 'rgba(173, 216, 230, 0.5)';
                this.targetX = 0;
                this.targetY = 0;
                this.baseY = 0;
                this.targetType = null;
                this.targetColor = null;
            }
            update(state, isDrifting, bias = { inertia: 0, integration: 0 }) {
                if (state === 'NIRODHA') {
                    this.vx *= 0.95;
                    this.vy *= 0.95;
                    this.alpha *= 0.98;
                    this.x += this.vx;
                    this.y += this.vy;
                } else if (state === 'MANIFESTATION' || state === 'EXTERNAL_CONTROL') {
                    // Use target seeking if we have a target set (either Face or External)
                    // For EXTERNAL_CONTROL, we rely on targetX/Y being set by handleInstruction
                    const hasTarget = (state === 'MANIFESTATION' && this.targetType) || (state === 'EXTERNAL_CONTROL');

                    if (hasTarget) {
                        // Logenesis Force Physics (Spring/Elastic)
                        const dx = this.targetX - this.x;
                        const dy = this.targetY - this.y;

                        // Accelerate towards target
                        this.vx += dx * 0.05;
                        this.vy += dy * 0.05;

                        // Apply friction/damping
                        this.vx *= 0.8;
                        this.vy *= 0.8;

                        this.x += this.vx;
                        this.y += this.vy;

                        this.alpha = Math.min(0.9, this.alpha + 0.02);
                        this.color = this.targetColor || '#ffffff';
                    } else {
                        this.x += this.vx;
                        this.y += this.vy;
                        this.alpha = Math.max(0, this.alpha - 0.02);
                    }
                } else {
                    const dampening = 1 - (bias.inertia * 0.05);
                    this.vx *= dampening;
                    this.vy *= dampening;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.alpha = Math.min(0.6, this.alpha + 0.01);
                    if (bias.inertia > 0.5) {
                         this.color = `rgba(100, 150, 100, ${this.alpha})`;
                    } else {
                         this.color = `rgba(34, 197, 94, ${this.alpha})`;
                    }
                    if (isDrifting) {
                        const driftForce = 1.5 * (1 + bias.integration);
                        this.x += (Math.random() - 0.5) * driftForce;
                        this.y += (Math.random() - 0.5) * driftForce;
                    }
                    if (this.x < 0 || this.x > this.canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > this.canvas.height) this.vy *= -1;
                }
            }
            draw(ctx) {
                if (this.alpha <= 0.01) return;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * GunUI Engine
         */
        class GunUI {
            constructor() {
                this.bus = new AetheBus();
                this.memory = new AetherMemory();
                this.canvas = document.getElementById('gun-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.state = 'NIRODHA';
                this.tapCount = 0;
                this.isSleeping = false;
                this.currentBias = { inertia: 0, integration: 0 };
                this.lastInteraction = Date.now();
                this.faceTopology = null;
                this.faceTargets = [];

                // Network
                this.ws = null;
                this.pendingRecall = null; // Store proposal to act on

                this.init();
                this.setupAetheBus();
                this.setupInput();
                this.connect();
            }

            init() {
                window.addEventListener('resize', () => this.resize());
                this.resize();
                for(let i=0; i<800; i++) this.particles.push(new Particle(this.canvas));

                // Touch/Click
                const handleTap = (e) => {
                    // Don't trigger tap logic if clicking UI elements
                    if (e.target.closest('#input-layer') || e.target.closest('#recall-modal')) return;
                    this.handleTap(e);
                };
                window.addEventListener('touchstart', handleTap);
                window.addEventListener('mousedown', handleTap);

                // Key listener for hidden input
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        // Toggle input layer
                        const layer = document.getElementById('input-layer');
                        layer.style.display = layer.style.display === 'block' ? 'none' : 'block';
                        if (layer.style.display === 'block') document.getElementById('cmd-input').focus();
                    }
                });

                this.render();
            }

            connect() {
                // Determine WS URL
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const host = window.location.host || 'localhost:8000';
                // In local dev without real server serving html, this might fail, so we default to localhost:8000
                const wsUrl = `ws://localhost:8000/ws`;

                this.log(`NET: Connecting to ${wsUrl}...`);
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    this.log("NET: Uplink Established.");
                };

                this.ws.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        if (msg.type === 'STATE') {
                            // Ignored: Physics sync
                        } else if (msg.type === 'LOGENESIS_RESPONSE') {
                            this.handleLogenesisResponse(msg);
                        } else if (msg.intent) {
                             this.handleInstruction(msg);
                        }
                    } catch (e) {
                        console.error(e);
                    }
                };

                this.ws.onclose = () => {
                    this.log("NET: Uplink Severed. Retrying in 5s...");
                    setTimeout(() => this.connect(), 5000);
                };
            }

            setupInput() {
                const input = document.getElementById('cmd-input');
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const text = input.value.trim();
                        if (text) this.sendText(text);
                        input.value = '';
                        document.getElementById('input-layer').style.display = 'none';
                    }
                });

                // Recall Modal Buttons
                document.getElementById('btn-ignore').addEventListener('click', () => {
                    document.getElementById('recall-modal').style.display = 'none';
                    this.pendingRecall = null;
                });

                document.getElementById('btn-recall').addEventListener('click', () => {
                    if (this.pendingRecall) {
                        this.executeRecall(this.pendingRecall);
                    }
                    document.getElementById('recall-modal').style.display = 'none';
                });
            }

            // Command parser for test purposes
            sendText(text, recalledContext = null) {
                this.log(`USER: ${text}`);

                // Local Command: /save <topic> <content>
                if (text.startsWith('/save ')) {
                    const parts = text.split(' ');
                    if (parts.length >= 3) {
                        const topic = parts[1];
                        const summary = parts.slice(2).join(' ');
                        this.memory.saveConversation(topic, summary);
                        this.log(`MEM: Saved topic '[${topic}]'.`);
                        return;
                    }
                }

                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const payload = {
                        mode: "logenesis",
                        input: {
                            text: text,
                            session_id: "pwa_session_" + this.currentBias.integration,
                            memory_index: this.memory.getIndex(),
                            recalled_context: recalledContext
                        }
                    };
                    this.ws.send(JSON.stringify(payload));
                } else {
                    this.log("NET: Offline. Cannot transmit.");
                }
            }

            handleLogenesisResponse(res) {
                // Update State
                this.bus.publish('INTENT_CHANGE', {
                    state: res.state,
                    hex: res.visual_qualia.color,
                    phi: res.intent_debug.decision_urgency // use urgency as phi proxy
                });

                // Show Text
                if (res.text_content) {
                    this.log(`AI: ${res.text_content}`);
                }

                // Handle Recall Proposal
                if (res.recall_proposal) {
                    this.showRecallModal(res.recall_proposal);
                }
            }

            handleInstruction(instr) {
                this.log(`LCL: ${instr.intent}`);

                if (instr.intent === 'MANIFEST' || instr.intent === 'SPAWN') {
                    if (instr.formation_data) {
                        this.bus.publish('INTENT_CHANGE', { state: 'EXTERNAL_CONTROL', hex: '#FFFFFF', phi: 0.9 });

                        // Shuffle particles to avoid ordering artifacts
                        const shuffled = [...this.particles].sort(() => 0.5 - Math.random());

                        instr.formation_data.forEach((pt, i) => {
                            if (i < shuffled.length) {
                                const p = shuffled[i];
                                // pt is [x, y, color] normalized 0..1
                                p.targetX = pt[0] * this.canvas.width;
                                p.targetY = pt[1] * this.canvas.height;
                                p.targetColor = pt[2] === 'default' ? '#ffffff' : pt[2];
                                p.alpha = Math.max(p.alpha, 0.5);
                            }
                        });
                    }
                } else if (instr.intent === 'MOVE') {
                     if (instr.vector) {
                         const forceX = instr.vector[0] * 5.0;
                         const forceY = instr.vector[1] * 5.0;
                         this.particles.forEach(p => {
                             p.vx += forceX;
                             p.vy += forceY;
                         });
                         // Switch to Organic state so they move freely
                         if (this.state === 'EXTERNAL_CONTROL' || this.state === 'MANIFESTATION') {
                              this.bus.publish('INTENT_CHANGE', { state: 'LOGENESIS', hex: '#FFFFFF', phi: 0.5 });
                         }
                     }
                } else if (instr.intent === 'ERASE') {
                    this.particles.forEach(p => p.alpha = 0);
                }
            }

            showRecallModal(proposal) {
                this.pendingRecall = proposal;
                const modal = document.getElementById('recall-modal');
                document.getElementById('recall-text').innerText = proposal.question;
                modal.style.display = 'block';
            }

            executeRecall(proposal) {
                const summary = this.memory.getSummary(proposal.memory_id);
                if (summary) {
                    this.log(`RECALL: Integrating '[${proposal.topic}]'...`);
                    // We need to re-send the original intent or a confirmation.
                    // For flow simplicity, we send a system confirmation
                    this.sendText(`[SYSTEM: USER CONFIRMED RECALL OF '${proposal.topic}']`, summary);
                }
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.faceTopology = new FaceTopology(
                    this.canvas.width/2,
                    this.canvas.height/2,
                    Math.min(this.canvas.width, this.canvas.height) * 0.25
                );
                this.faceTargets = this.faceTopology.generate();
            }

            setupAetheBus() {
                this.bus.subscribe('INTENT_CHANGE', (data) => {
                    this.state = data.state;
                    this.updateUI(data);
                });
            }

            handleTap(e) {
                this.lastInteraction = Date.now();
                if (this.isSleeping) {
                    this.isSleeping = false;
                    this.render();
                }
                if (this.state === 'AWAKE' || this.state === 'LOGENESIS') {
                    this.manifest();
                    return;
                }
                if (this.state === 'MANIFESTATION') {
                     this.bus.publish('INTENT_CHANGE', { state: 'LOGENESIS', hex: '#06b6d4', phi: 0.85 });
                     return;
                }
                if (this.state !== 'NIRODHA') return;

                this.tapCount++;
                const indicators = document.querySelectorAll('.indicator');
                if (indicators[this.tapCount-1]) indicators[this.tapCount-1].style.background = 'white';

                if (this.tapCount === 3) {
                    this.wake();
                }
            }

            wake() {
                const snapshot = this.memory.getSnapshot();
                this.currentBias = IntentResolver.calculateBias(snapshot);
                this.memory.recordAwakening();
                this.log("RITUAL: Sequence Verified.");
                this.log("HINT: Press Ctrl+Enter for Input");
                document.getElementById('ritual-layer').style.display = 'none';
                document.getElementById('ui-layer').style.opacity = '1';
                this.bus.publish('INTENT_CHANGE', { state: 'LOGENESIS', hex: '#06b6d4', phi: 0.85 });
            }

            manifest() {
                if (this.state === 'MANIFESTATION') return;
                const refusalChance = 0.3 + (this.currentBias.inertia * 0.5);
                if (Math.random() < refusalChance) {
                    this.log(`SYSTEM: Inertia High. Refused.`);
                    return;
                }
                this.log("MANIFEST: Biometric Lock Engaged.");
                this.bus.publish('INTENT_CHANGE', { state: 'MANIFESTATION', hex: '#64C8FF', phi: 0.99 });
                const shuffled = [...this.particles].sort(() => 0.5 - Math.random());
                shuffled.forEach((p, index) => {
                    const target = this.faceTargets[index % this.faceTargets.length];
                    if (target) {
                        p.targetX = target.x;
                        p.targetY = target.y;
                        p.baseY = target.y;
                        p.targetType = target.type;
                        p.targetColor = target.color;
                    }
                });
            }

            speak(amplitude) {
                const time = Date.now() * 0.02;
                this.particles.forEach(p => {
                    if (p.targetType === 'MOUTH') {
                        const open = Math.sin(time) * amplitude * 15;
                        p.targetY = p.baseY + open;
                    }
                });
            }

            updateUI(data) {
                document.getElementById('intent-tag').innerText = data.state;
                document.getElementById('intent-tag').style.color = data.hex;
                document.getElementById('status-glow').style.background = data.hex;
                let narrative = "VOID";
                const pct = data.phi * 100;
                if (pct > 0 && pct <= 30) narrative = "NEBULA";
                else if (pct <= 70) narrative = "RESONANCE";
                else if (pct < 100) narrative = "MANIFESTATION";
                document.getElementById('phi-val').innerText = narrative;
                document.getElementById('phi-bar').style.width = pct + '%';
            }

            log(msg) {
                const term = document.getElementById('terminal');
                const div = document.createElement('div');
                div.className = 'terminal-line';
                div.innerText = `> ${msg}`;
                term.prepend(div);
                if (term.children.length > 5) term.lastChild.remove();
            }

            render() {
                if (this.state === 'NIRODHA' && this.tapCount === 0) {
                     const activeParticles = this.particles.filter(p => p.alpha > 0.01).length;
                     if (activeParticles === 0) {
                         this.isSleeping = true;
                         this.ctx.fillStyle = '#050505';
                         this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                         return;
                     }
                }
                this.ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                const idleTime = Date.now() - this.lastInteraction;
                const isDrifting = (this.state !== 'NIRODHA' && this.state !== 'MANIFESTATION' && idleTime > 5000);

                if (this.state === 'MANIFESTATION') {
                    const time = Date.now() * 0.005;
                    const amp = (Math.sin(time) * 0.3) + (Math.random() > 0.8 ? Math.random() * 0.5 : 0);
                    this.speak(amp);
                }

                this.particles.forEach(p => {
                    p.update(this.state, isDrifting, this.currentBias);
                    p.draw(this.ctx);
                });

                if (!this.isSleeping) {
                    requestAnimationFrame(() => this.render());
                }
            }
        }

        const app = new GunUI();
    </script>
</body>
</html>