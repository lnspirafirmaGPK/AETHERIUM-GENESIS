<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aetherium Genesis — Actuator UI</title>
<style>
  :root{--bg:#000;--accent:#ffb86b;--accent2:#7befff}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto}

  #viewport{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
  canvas{position:absolute;inset:0;display:block}
  .ui-layer{position:absolute;left:0;right:0;bottom:24px;display:flex;justify-content:center;pointer-events:none}
  .actuator{pointer-events:auto;background:linear-gradient(135deg,var(--accent),#ff6b6b);border-radius:999px;padding:14px 22px;display:flex;align-items:center;gap:12px;box-shadow:0 8px 30px rgba(255,120,60,0.12);border:1px solid rgba(255,255,255,0.04);cursor:pointer;user-select:none}
  .actuator .dot{width:14px;height:14px;border-radius:50%;background:rgba(255,255,255,0.9);box-shadow:0 0 12px rgba(255,200,120,0.9)}
  .label{font-size:14px;font-weight:600;color:#050505}
  .sub{font-size:11px;color:rgba(5,5,5,0.6);opacity:0.9}
  .status{position:absolute;bottom:110px;left:50%;transform:translateX(-50%);font-size:13px;color:rgba(255,255,255,0.6);pointer-events:none}
  @media (max-width:520px){ .actuator{padding:10px 16px} .label{font-size:13px} .status{bottom:90px} }
</style>
</head>
<body>
<div id="viewport">
  <canvas id="scene"></canvas>
  <div class="status" id="status">Idle</div>
  <div class="ui-layer">
    <div id="actuator" class="actuator" role="button" aria-pressed="false" aria-label="Start voice interaction">
      <div style="display:flex;flex-direction:column;gap:2px">
        <div class="label">Touch to speak</div>
        <div class="sub">สัมผัสเพื่อสนทนา</div>
      </div>
      <div class="dot" id="act-dot"></div>
    </div>
  </div>
</div>

<script>
/* Configuration */
const WS_URL = 'ws://' + (window.location.host || 'localhost:8000') + '/ws';
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d', { alpha: true });
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

/* State */
const State = { IDLE:'idle', LISTENING:'listening', PROCESSING:'processing', RESONATING:'resonating' };
let currentState = State.IDLE;
const statusEl = document.getElementById('status');
const actuator = document.getElementById('actuator');
const actDot = document.getElementById('act-dot');

function setState(s){
  currentState = s;
  statusEl.textContent = s.charAt(0).toUpperCase() + s.slice(1);
  actuator.setAttribute('aria-pressed', s !== State.IDLE);
  if(s === State.IDLE){ actDot.style.transform = 'scale(1)'; actDot.style.boxShadow = '0 0 12px rgba(255,200,120,0.9)'; }
  if(s === State.LISTENING){ actDot.style.transform = 'scale(1.4)'; actDot.style.boxShadow = '0 0 28px rgba(123,239,255,0.95)'; }
  if(s === State.PROCESSING){ actDot.style.transform = 'scale(1.1)'; actDot.style.boxShadow = '0 0 18px rgba(255,140,80,0.9)'; }
  if(s === State.RESONATING){ actDot.style.transform = 'scale(0.9)'; actDot.style.boxShadow = '0 0 40px rgba(255,255,255,0.95)'; }
}

/* Particles */
const PARTICLE_COUNT = 900;
const particles = [];
for(let i=0;i<PARTICLE_COUNT;i++){
  particles.push({
    x: Math.random()*width,
    y: Math.random()*height,
    vx: (Math.random()-0.5)*0.6,
    vy: (Math.random()-0.5)*0.6,
    size: Math.random()*1.6 + 0.6,
    hue: Math.random()*360,
    target: null
  });
}
let globalPulse = 0;
let baseHue = 200; // Default Blue
let targetHue = 200;
let turbulence = 0.1;

function hexToHue(hex) {
    // Simple naive conversion for demo
    // In real app, convert RGB to HSL properly
    if(hex.includes('#')) hex = hex.replace('#','');
    const r = parseInt(hex.substring(0,2), 16);
    const g = parseInt(hex.substring(2,4), 16);
    const b = parseInt(hex.substring(4,6), 16);
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if(max == min){ h = 0; }
    else {
        let d = max - min;
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return h * 360;
}

function renderParticles(){
  ctx.clearRect(0,0,width,height);
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fillRect(0,0,width,height);

  // Hue LERP
  baseHue += (targetHue - baseHue) * 0.05;

  for(const p of particles){
    // Update Logic
    if(currentState === State.RESONATING && p.target){
      const dx = p.target.x - p.x;
      const dy = p.target.y - p.y;

      // Attraction to target
      p.vx += dx * 0.005 * (1 + globalPulse);
      p.vy += dy * 0.005 * (1 + globalPulse);

      // Turbulence
      p.vx += (Math.random()-0.5) * turbulence;
      p.vy += (Math.random()-0.5) * turbulence;

      // Damping
      p.vx *= 0.92;
      p.vy *= 0.92;
    } else {
      // Idle Drift
      p.vx += (Math.random()-0.5)*0.08;
      p.vy += (Math.random()-0.5)*0.08;

      // Center pull
      p.vx += (width/2 - p.x) * 0.00001;
      p.vy += (height/2 - p.y) * 0.00001;

      p.vx *= 0.99;
      p.vy *= 0.99;
    }

    p.x += p.vx; p.y += p.vy;
    if(p.x < 0) p.x = width; if(p.x > width) p.x = 0;
    if(p.y < 0) p.y = height; if(p.y > height) p.y = 0;

    const hue = (baseHue + p.hue * 0.1) % 360; // Base hue dominant
    const alpha = Math.min(0.95, 0.08 + Math.hypot(p.vx,p.vy)*0.6 + globalPulse*0.25);
    ctx.fillStyle = `hsla(${hue}, 85%, 60%, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * (1 + globalPulse*0.6), 0, Math.PI*2);
    ctx.fill();
  }
}

/* Speech Recognition */
let recognition;
let finalTranscript = '';

function setupRecognition() {
    if ('webkitSpeechRecognition' in window) {
        recognition = new webkitSpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'th-TH'; // Default to Thai as per report

        recognition.onstart = function() {
            console.log("Recognition started");
        };

        recognition.onresult = function(event) {
            finalTranscript = event.results[0][0].transcript;
            console.log("Transcript: ", finalTranscript);
        };

        recognition.onerror = function(event) {
             console.error("Recognition error", event.error);
             stopListening();
        };

        recognition.onend = function() {
             console.log("Recognition ended");
             stopListening();
        };
    } else {
        console.warn("Web Speech API not supported");
    }
}
setupRecognition();

/* Audio capture & simple VAD */
let audioCtx, analyser, dataArray, sourceNode, mediaStream;
let listeningStart = 0;
let vadTimer = null;

async function startListening(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') await audioCtx.resume();

  // Start STT
  if(recognition) {
      finalTranscript = '';
      try { recognition.start(); } catch(e){}
  }

  try {
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch(err){
    console.error('Microphone access denied', err);
    return;
  }
  sourceNode = audioCtx.createMediaStreamSource(mediaStream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  sourceNode.connect(analyser);
  dataArray = new Uint8Array(analyser.frequencyBinCount);
  setState(State.LISTENING);
  listeningStart = performance.now();
  vadLoop();
  sendWS({ type:'INTENT_START', meta:{ ts: Date.now() } });
}

function stopListening(){
  if(mediaStream) mediaStream.getTracks().forEach(t => t.stop());
  if(sourceNode){ sourceNode.disconnect(); sourceNode = null; }
  if(analyser){ analyser.disconnect(); analyser = null; }
  if(recognition) { try { recognition.stop(); } catch(e){} }

  setState(State.PROCESSING);

  // Send recognized text if available
  if(finalTranscript && finalTranscript.length > 0) {
      sendWS({ type:'INTENT_RECOGNIZED', text: finalTranscript });
  } else {
      // Fallback or just signal end
      sendWS({ type:'INTENT_END', meta:{ duration: performance.now() - listeningStart } });
  }
}

/* energy-based VAD (Visual Only) */
function vadLoop(){
  if(!analyser) return;
  analyser.getByteTimeDomainData(dataArray);
  let sum = 0;
  for(let i=0;i<dataArray.length;i++){
    const v = (dataArray[i] - 128) / 128;
    sum += v*v;
  }
  const rms = Math.sqrt(sum / dataArray.length);
  globalPulse = Math.min(1, rms * 6);
  requestAnimationFrame(vadLoop);
}

/* WebSocket AetherBus */
let ws;
function connectWS(){
  ws = new WebSocket(WS_URL);
  ws.addEventListener('open', ()=> console.log('AetherBus connected'));
  ws.addEventListener('message', (ev)=> {
    try {
      const msg = JSON.parse(ev.data);
      handleAetherMessage(msg);
    } catch(e){ console.error('Invalid WS message', e); }
  });
  ws.addEventListener('close', ()=> setTimeout(connectWS, 2000));
}
connectWS();

function sendWS(payload){
  if(ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(payload));
}

/* Handle server messages */
function handleAetherMessage(msg){
  if(msg.type === 'VISUAL_PARAMS'){
    applyVisualParams(msg.params || {});
  } else if(msg.type === 'AI_SPEAK'){
    triggerAIResponse(msg.text || '');
  } else if(msg.type === 'MANIFEST'){
    setParticleTargetsFromCoords(msg.coords || []);
    setState(State.RESONATING);
  } else if(msg.type === 'LOGENESIS_RESPONSE' || msg.type === 'LightInstruction'){
    const params = legacyToVisual(msg);
    applyVisualParams(params);
  }
}

function legacyToVisual(msg){
  return {
    base_shape: "cloud", // Default
    color_palette: "#FFFFFF",
    turbulence: 0.1
  };
}

function applyVisualParams(params){
  console.log("Applying Visuals:", params);

  // 1. Color
  if(params.color_palette) targetHue = hexToHue(params.color_palette);

  // 2. Turbulence
  turbulence = params.turbulence || 0.1;

  // 3. Shape Generation (Morphing)
  const shape = params.base_shape || 'cloud';
  const targets = generateShapeTargets(shape, particles.length);

  setParticleTargetsFromCoords(targets);
  setState(State.RESONATING);
}

function generateShapeTargets(shape, count) {
    const targets = [];
    const cx = width / 2;
    const cy = height / 2;
    const minDim = Math.min(width, height);

    for(let i=0; i<count; i++) {
        let x, y;
        if(shape === 'sphere' || shape === 'circle' || shape === 'orb') {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.sqrt(Math.random()) * (minDim * 0.25); // Uniform disk
            x = cx + Math.cos(angle) * r;
            y = cy + Math.sin(angle) * r;
        }
        else if (shape === 'vortex' || shape === 'spiral') {
            const angle = i * 0.1;
            const r = (i / count) * (minDim * 0.35);
            x = cx + Math.cos(angle) * r;
            y = cy + Math.sin(angle) * r;
        }
        else if (shape === 'cube' || shape === 'box') {
            const size = minDim * 0.4;
            x = cx + (Math.random() - 0.5) * size;
            y = cy + (Math.random() - 0.5) * size;
        }
        else if (shape === 'line') {
             x = (i / count) * (width * 0.8) + (width * 0.1);
             y = cy + (Math.random()-0.5) * 50;
        }
        else if (shape === 'scatter') {
             x = Math.random() * width;
             y = Math.random() * height;
        }
        else { // Cloud / Nebula
             const angle = Math.random() * Math.PI * 2;
             const r = Math.random() * (minDim * 0.4);
             // Perlin-ish noise distribution (fake)
             x = cx + Math.cos(angle) * r;
             y = cy + Math.sin(angle) * r * 0.6; // Flattened
        }
        targets.push({x, y});
    }
    return targets;
}

function setParticleTargetsFromCoords(coords){
  for(let i=0;i<particles.length;i++){
    const c = coords[i % coords.length];
    particles[i].target = { x: c.x, y: c.y };
  }
}

function triggerAIResponse(text){
  if('speechSynthesis' in window){
    const utter = new SpeechSynthesisUtterance(text);
    // Try multiple languages
    utter.lang = 'th-TH';
    utter.onstart = ()=> { setState(State.RESONATING); globalPulse = 0.9; };
    utter.onend = ()=> { globalPulse = 0; setTimeout(()=> setState(State.IDLE), 2000); };
    speechSynthesis.speak(utter);
  } else {
    setState(State.RESONATING);
    setTimeout(()=> setState(State.IDLE), 2000);
  }
}

/* Actuator interactions */
actuator.addEventListener('pointerdown', async (e) => {
  e.preventDefault();
  if(currentState === State.IDLE){
    await startListening();
  } else if(currentState === State.LISTENING){
    stopListening();
  } else if(currentState === State.RESONATING){
    setState(State.IDLE);
    sendWS({ type:'RESET' });
  }
});

/* Resize & loop */
window.addEventListener('resize', ()=> { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; });
function loop(){
  globalPulse = Math.max(0, globalPulse * 0.96 - 0.002);
  colorShift = (colorShift + 0.05) % 360;
  renderParticles();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
